<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <title>Face Recognition System</title>
</head>
<body>
    <div class="header">
        <h1>Face Recognition System</h1>
        <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
    </div>

    <div class="side-form-section">
        <h1 class="section-heading">Upload or Capture an Image</h1>
    
        <div class="form-row">
            <!-- Upload Form -->
            <form class="upload-form" action="/" method="post" enctype="multipart/form-data" onsubmit="return validateUploadForm()">
                <h2>Upload</h2>
                <input type="file" name="file" id="fileInput" accept="image/*" onchange="showPreview()">
                <div class="preview" id="uploadPreview"></div> <!-- Preview for uploaded image -->
                <button type="submit">Upload</button>
            </form>
    
            <!-- Capture Form -->
            <form class="capture-form" action="/" method="post" onsubmit="return validateCaptureForm()">
                <h2>Capture</h2>
                <video id="video" autoplay style="display: none;"></video>
                <canvas id="canvas" style="display:none;"></canvas>
                <input type="hidden" name="captured_image" id="capturedImage">
    
                <div class="button-row">
                    <button type="button" id="capture-btn" onclick="startAndCapture()">üì∏ Capture</button>
                    <button type="button" id="retake-btn" onclick="retakeImage()" style="display: none;">üîÅ Retake</button>
                    <button type="submit">Submit</button>
                </div>
    
                <div class="preview" id="capturePreview"></div> <!-- Preview for captured image -->
            </form>
        </div>
    </div>        

    <div class="footer">¬© 2025 Face Recognition App</div>

    <script>
        // State to check if the webcam is already enabled
        let cameraInitialized = false;
        let stream = null;  // Store the camera stream for later cleanup

        // Start and display video stream
        function startAndCapture() {
            const video = document.getElementById('video');

            // If the camera is already initialized, just show the video stream
            if (!cameraInitialized) {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then((stream) => {
                        video.srcObject = stream;
                        video.style.display = "block";
                        cameraInitialized = true;  // Mark the camera as initialized
                        stream = stream;  // Store the stream for later cleanup
                    })
                    .catch((err) => {
                        console.error("Camera error:", err);
                        alert("Please allow camera access to use this feature.");
                    });
            } else {
                captureImage(); // If camera is already initialized, just capture the image
            }
        }

        // Capture and resize the image from the video feed
        function captureImage() {
            const video = document.getElementById("video");
            const canvas = document.getElementById("canvas");
            const context = canvas.getContext("2d");
            const preview = document.getElementById("capturePreview");
            const capturedImageInput = document.getElementById("capturedImage");

            const maxWidth = 800;  // Max width of the captured image
            const maxHeight = 600; // Max height of the captured image

            let width = video.videoWidth;
            let height = video.videoHeight;

            // Calculate new dimensions based on maxWidth and maxHeight
            if (width > maxWidth || height > maxHeight) {
                const ratio = width / height;
                if (width > height) {
                    width = maxWidth;
                    height = Math.round(width / ratio);
                } else {
                    height = maxHeight;
                    width = Math.round(height * ratio);
                }
            }

            // Set canvas size to match the resized image
            canvas.width = width;
            canvas.height = height;

            // Draw the current video frame on the canvas with new dimensions
            context.drawImage(video, 0, 0, width, height);

            // Convert the resized canvas to an image and display it in preview
            const imageData = canvas.toDataURL("image/png");
            capturedImageInput.value = imageData;
            preview.innerHTML = `<img src="${imageData}" alt="Captured Image">`;

            // Hide the video stream and show the retake button
            video.style.display = "none";
            document.getElementById("retake-btn").style.display = "inline-block";
        }

        // Stop the camera stream when done
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;  // Clean up the stream
            }
        }

        // Reset for retaking the image
        function retakeImage() {
            document.getElementById("capturePreview").innerHTML = "";
            document.getElementById("capturedImage").value = "";
            document.getElementById("retake-btn").style.display = "none";
            stopCamera();  // Stop the camera when retaking
            startAndCapture();  // Restart the camera
        }

        // Show preview of uploaded image
        function showPreview() {
            const file = document.getElementById("fileInput").files[0];
            const reader = new FileReader();
            reader.onload = function (e) {
                document.getElementById("uploadPreview").innerHTML = `<img src="${e.target.result}" alt="Uploaded Image">`;
            }
            reader.readAsDataURL(file);
        }

        // Validate that a file is selected in the upload form
        function validateUploadForm() {
            if (!document.getElementById("fileInput").files.length) {
                alert("Please select a file to upload.");
                return false;
            }
            return true;
        }

        // Validate that an image is captured in the capture form
        function validateCaptureForm() {
            if (!document.getElementById("capturedImage").value) {
                alert("Please capture an image before submitting.");
                return false;
            }
            return true;
        }

        // Theme toggle functionality
        document.addEventListener('DOMContentLoaded', function () {
            if (localStorage.getItem('theme') === 'dark') {
                document.body.classList.add('dark-mode');
                document.querySelector('.theme-toggle').textContent = "‚òÄÔ∏è Light Mode";
            }
        });

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            let btn = document.querySelector('.theme-toggle');
            btn.textContent = document.body.classList.contains('dark-mode') ? "‚òÄÔ∏è Light Mode" : "üåô Dark Mode";
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }
    </script>
</body>
</html>
